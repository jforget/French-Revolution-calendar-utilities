<html>
<head>
<meta http-equiv='content-type' content='Text/html; charset=utf-8' />
<title>Analyzing the equinox rule</title>
<style>
<!--
.insert    { background-color: skyblue}
.call      { background-color: yellow}
.condcode  { background-color: lightgrey }
.condition { font-size-adjust: .5 }
-->
</style>
</head>
<body>
<a href='#Analyzing the equinox rule'>Analyzing the equinox rule</a>
<br /><a href='#eqrule∆license'><tt>eqrule∆license</tt></a>
<br /><a href='#Introduction'>Introduction</a>
<br /><a href='#Theoretical Analysis'>Theoretical Analysis</a>
<br /><a href='#Statistical Analysis'>Statistical Analysis</a>
<br /><a href='#eqrule∆vnd1eq'><tt>eqrule∆vnd1eq</tt></a>
<br /><a href='#eqrule∆vnd1ar'><tt>eqrule∆vnd1ar</tt></a>
<br /><a href='#Computing the moving averages'>Computing the moving averages</a>
<br /><a href='#eqrule∆movingav'><tt>eqrule∆movingav</tt></a>
<hr /><h1><a name='Analyzing the equinox rule'>Analyzing the equinox rule</a></h1>
<h2><a name='eqrule∆license'><tt>eqrule∆license</tt></a></h2>
<p>
The text part of this repository is licensed under the terms of
Creative Commons, with attribution and share-alike (CC-BY-SA).
The code part of this repository is licensed with the GPL version
1.0 or later or the Artistic License.
</p>

<p>
As required by the GPL, each file with code must start with a one-line
description of the program and the summary of the GPL. Here it is.
</p>

<pre>
#!/usr/bin/apl -f
∇ eqrule∆license
'APL programs to analyze the equinox rule for the French Revolutionary calendar'
'and compare it with the arithmetic rule.'
''
'Copyright (C) 2019 Jean Forget  (JFORGET at cpan dot org)'
''
' This program is distributed under the same terms as Perl 5.16.3:'
' GNU Public License version 1 or later and Perl Artistic License'
''
' You can find the text of the licenses in the LICENSE file or at'
' https://dev.perl.org/licenses/artistic.html'
' and https://www.gnu.org/licenses/gpl-1.0.html.'
''
' Here is the summary of GPL:'
''
' This program is free software; you can redistribute it and/or modify'
' it under the terms of the GNU General Public License as published by'
' the Free Software Foundation; either version 1, or (at your option)'
' any later version.'
''
' This program is distributed in the hope that it will be useful,'
' but WITHOUT ANY WARRANTY; without even the implied warranty of'
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
' GNU General Public License for more details.'
''
' You should have received a copy of the GNU General Public License'
' along with this program; if not, write to the Free Software Foundation,'
' Inc., &lt;https://www.fsf.org/&gt;.'
∇
</pre>
<p>
As you can see, this summary is executable code included in the software.
So, after you have logged into APL and initialised your workspace with
my script, you can display this summary at any moment.
</p>

<h1><a name='Introduction'>Introduction</a></h1>
<p>
The programs below are meant to analyze the equinox rule used for the
French Revolutionary calendar, as implemented by Nachum Dershowitz
and Edward Reingold in C-Lisp.</p>

<p>
The main question is to determine for how long the functions from CALENDRICA 3.0
give the proper computations for the autumn equinox. I do not aim to
pretend that the authors may have left some bugs in their program.
I just want to give hints to users so they can build their own opinions
and determine whether the functions will be accurate for the next 10 millenia
or only for the next two centuries.</p>

<p>
Yet, I draw your attention to the "NO WARRANTY" clause in the licenses.
I only suggest ideas and explanations. But <em>you</em> build your own
conclusions, under your own responsibility. Neither Dershowitz, nor Reingold,
nor me, nor any person directly or indirectly involved in these texts and programs
can be held responsible for what you do with the texts and programs.
</p>

<h1><a name='Theoretical Analysis'>Theoretical Analysis</a></h1>
<p>
An astronomical year, or a tropical year, lasts
31&nbsp;556&nbsp;925.9747&nbsp;seconds, that is 365.242198781&nbsp;days. This gives
us the average duration of a French Revolutionary year using the equinox rule.
If we subtract the 365 whole days, the remainder is 0.242198781&nbsp;day, or
20&nbsp;925.9747 seconds.
With the arithmetic rule, the French Revolutionary year average duration is
365.24225&nbsp;days, that is 365&nbsp;days plus 20&nbsp;930.4&nbsp;seconds.
On average the Gregorian year lasts 365.2425&nbsp;days, that is 365&nbsp;days plus
20&nbsp;952&nbsp;seconds.</p>

<p>
The astronomical year has 4.4253&nbsp;seconds fewer than the arithmetic French Revolutionary year
and 27.0253&nbsp;seconds fewer than the Gregorian year. We can expect that
compared with the arithmetic French Revolutionary year,
the astronomical year will shift by one day in 19&nbsp;524&nbsp;years and
3197&nbsp;years will be sufficient to shift the astronomical year by one day when
compared with the Gregorian year.
</p>

<h1><a name='Statistical Analysis'>Statistical Analysis</a></h1>
<p>
Since we have been talking about mean durations, we have to work on lists of years
with a sufficient length so we can extract individual durations, compute average
durations and find the trend. To obtain the list, we run <tt>cmpeq.cl</tt> and we
store the output in a text file. The content is:
</p>

<pre>
0   0    1    1 1
1...5....0....5.7
   3 1794 22 22  
   4 1795 23 22 +
   5 1796 22 22  
</pre>
<p>
Columns 1 to 4: French Revolutionary year (with leading zeros replaced by spaces),</p>

<p>
Columns 6 to 9: Gregorian year,</p>

<p>
Columns 11 and 12: day number in September for the 1st Vendémiaire, using the equinox rule,</p>

<p>
Columns 14 and 15: day number in September for the 1st Vendémiaire, using the arithmetic rule,</p>

<p>
Column 17: a character to pinpoint the years when the two rules differ.
</p>

<h2><a name='eqrule∆vnd1eq'><tt>eqrule∆vnd1eq</tt></a></h2>
<p>
Since the data in the file produced by <tt>cmpeq.cl</tt> have a fixed
length and a fixed position, extracting these values is very simple.
</p>

<pre>
∇ V ← eqrule∆vnd1eq FIC
V ← {⍎(⊃⍵)[11 12]} ⎕FIO[49] FIC
∇
</pre>
<h2><a name='eqrule∆vnd1ar'><tt>eqrule∆vnd1ar</tt></a></h2>
<p>
And for the arithmetic rule, it is very simple too:
</p>

<pre>
∇ V ← eqrule∆vnd1ar FIC
V ← {⍎(⊃⍵)[14 15]} ⎕FIO[49] FIC
∇
</pre>
<p>
The only problem is that it works only with GNU-APL and it will fail
with other APL interpreters.
</p>

<h2><a name='Computing the moving averages'>Computing the moving averages</a></h2>
<p>
So we have a vector V with N numeric values and we want to compute moving
averages over any P consecutive values. Obviously, we will obtain N+1-P results.
As explained elsewhere, we assume that N is 6000 and P is 400.
The first step is storing the values from V in the following table
(N+1-P lines, P columns):
</p>

<pre>
V[1]      V[2]       V[3]     ... V[P-1]   V[P]
V[2]      V[3]       V[4]     ... V[P]     V[P+1]
V[3]      V[4]       V[5]     ... V[P+1]   V[P+2]
...       ...        ...          ...      ...
V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-2]   V[N-1]
V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-1]   V[N]
</pre>
<p>
And then, computing the means is a piece of cake. But how do we build this array?
There are three ways to do it.</p>

<p>
The first way consist in building an array with N+1-P identical lines of N columns:
</p>

<pre>
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
...       ...        ...          ...      ...
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
</pre>
<p>
Then we apply a progressive rotate operation to the lines with one of:
</p>

<pre>
(¯1+⍳N+1-P)⌽V
(0,⍳N-P)⌽V
</pre>
<p>
which gives:
</p>

<pre>

 V[1]      V[2]       V[3]     ... V[N-1]       V[N]
 V[2]      V[3]       V[4]     ... V[N]         V[1]
 V[3]      V[4]       V[5]     ... V[1]         V[2]
 ...       ...        ...          ...          ...
 V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-(2+P)]   V[N-(1+P)]
 V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-(1+P)]   V[N-P]
</pre>
<p>
And then all we have to do is truncating the array by keeping the first P columns.
The problem is that we need two temporary arrays each with (N+1-P) lines
and N columns. With N=6000 and P=400, this gives a total space of 2 × 5601 × 6000,
or 67212000 values.
</p>

<p>
The second way to build the array consists in using an intermediate array T,
with N+1 columns and N+1-P lines. When this array is filled with the content of
V, the N elements from V fill the first N columns of the first line of T,
leaving the last position T[1;N+1] empty. So V is "rewinded" and "restarted" to
continue filling T and so, V[1] lands into T[1;N+1]. So T[2;1] is fed with V[2].
Then the second line of T is filled with the remainder of V, until T[2;N-1] is
filled with V[N]. So the last two positions are empty. V is once again rewinded,
V[1] lands into T[2;N], V[2] lands into T[2;N+1] and V[3] lands into T[3;1].
This array is:
</p>

<pre>
 1         2          3            N-1          N          N+1
V[1]      V[2]       V[3]     ... V[N-1]       V[N]        V[1]
V[2]      V[3]       V[4]     ... V[N]         V[1]        V[2]
V[3]      V[4]       V[5]     ... V[1]         V[2]        V[3]
...       ...        ...          ...          ...
V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-(2+P)]   V[N-(1+P)]  V[N-P]
V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-(1+P)]   V[N-P]      V[N+1-P]
</pre>
<p>
So, by the simple trick of adding one column, that is N+1-P values, we get
for nearly free the progressive rotation and we use one intermediate array
instead of two.</p>

<p>
But we can do even better. The progressive rotation pattern that exist when
looking at lines in succession can also be found when looking at columns in
succession. Therefore, the third way consists in building an array with N+1
columns and only P lines instead of N+1-P. Then this array is truncated to N+1-P
columns instead of P. And the last step consists in transposing the array to get
the final array that we were waiting for, with N+1-P lines and P columns. Of
course, we have two intermediate arrays instead of just one, but if we suppose
that P is less than N÷3, their total size is lower than the size of the
intermediate array of method 2. Here are both intermediate arrays:
</p>

<pre>
 1         2          3            N-1          N          N+1
V[1]      V[2]       V[3]     ... V[N-1]       V[N]        V[1]
V[2]      V[3]       V[4]     ... V[N]         V[1]        V[2]
V[3]      V[4]       V[5]     ... V[1]         V[2]        V[3]
...       ...        ...          ...          ...
V[P-1]    V[P]       V[P+1]   ... V[P-3]       V[P-2]      V[P-1]
V[P]      V[P+1]     V[P+2]   ... V[P-2]       V[P-1]      V[P]
</pre>
<p>
And then
</p>

<pre>
 1         2          3            N-(P+1)      N-P        N+1-P
V[1]      V[2]       V[3]     ... V[N-(P+1)]   V[N-P]      V[N+1-P]
V[2]      V[3]       V[4]     ... V[N-P]       V[N+1-P]    V[N+2-P]
V[3]      V[4]       V[5]     ... V[N+1-P]     V[N+2-P]    V[N+3-P]
...       ...        ...          ...          ...
V[P-1]    V[P]       V[P+1]   ... V[N-3]       V[N-2]      V[N-1]
V[P]      V[P+1]     V[P+2]   ... V[N-2]       V[N-1]      V[N]
</pre>
<p>
This will be the method we will use. Actually no. Because the array:
</p>

<pre>
V[1]      V[2]       V[3]     ... V[P-1]   V[P]
V[2]      V[3]       V[4]     ... V[P]     V[P+1]
V[3]      V[4]       V[5]     ... V[P+1]   V[P+2]
...       ...        ...          ...      ...
V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-2]   V[N-1]
V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-1]   V[N]
</pre>
<p>
is not the final step of the computation. The final step of the computation is
the vector of moving averages and this vector can be computed from the previous
intermediate array, the one before transposition. Instead of computing the sums
by lines with "<tt>+/</tt>", we will compute the sums by column with
"<tt>+⌿</tt>".
</p>

<h2><a name='eqrule∆movingav'><tt>eqrule∆movingav</tt></a></h2>
<p>
In the end, the function is:
</p>

<pre>
∇ R ← P eqrule∆movingav V;N;T
N ← (⍴V)[1]
T ← (P,N+1-P) ↑ (P,N+1) ⍴ V
R ← (+⌿T) ÷ P
∇
</pre>
</body>
</html>
