<html>
<head>
<meta http-equiv='content-type' content='Text/html; charset=utf-8' />
<title>Analyse de la règle des équinoxes</title>
<style>
<!--
.insert    { background-color: skyblue}
.call      { background-color: yellow}
.condcode  { background-color: lightgrey }
.condition { font-size-adjust: .5 }
-->
</style>
</head>
<body>
<a href='#Analyse de la règle des équinoxes'>Analyse de la règle des équinoxes</a>
<br /><a href='#equinoxrule∆license'><tt>equinoxrule∆license</tt></a>
<br /><a href='#Introduction'>Introduction</a>
<br /><a href='#Analyse théorique'>Analyse théorique</a>
<br /><a href='#Analyse statistique'>Analyse statistique</a>
<br /><a href='#equinoxrule∆vnd1eq'><tt>equinoxrule∆vnd1eq</tt></a>
<br /><a href='#equinoxrule∆vnd1ar'><tt>equinoxrule∆vnd1ar</tt></a>
<br /><a href='#Calcul des moyennes glissantes'>Calcul des moyennes glissantes</a>
<br /><a href='#equinoxrule∆movingav'><tt>equinoxrule∆movingav</tt></a>
<hr /><h1><a name='Analyse de la règle des équinoxes'>Analyse de la règle des équinoxes</a></h1>
<h2><a name='equinoxrule∆license'><tt>equinoxrule∆license</tt></a></h2>
<p>
La partie texte de ce dépôt git est distribuée sous la licence
Creative Commons avec attribution et partage dans les mêmes
conditions (CC-BY-SA). La partie code de ce dépôt est distribuée
sous la licence GPL version 1.0 ou ultérieure ou la licence artistique.
</p>

<p>
Ainsi que le requiert la licence GPL, tout fichier de code
doit commencer par un commentaire décrivant de façon sommaire
le logiciel et résumant la GPL. La description sommaire en français&nbsp;:</p>

<p>
«&nbsp;Les fonctions de ce script permettent d'analyser la règle des équinoxes
du calendrier républicain et de la comparer avec la règle arithmétique.&nbsp;»</p>

<p>
Quant au résumé de la GPL, le voici, en anglais (je ne suis
pas assez calé pour traduire en français un texte de teneur juridique).
</p>

<pre>
#!/usr/bin/apl -f
∇ equinoxrule∆license
'APL programs to analyze the equinox rule for the French Revolutionary calendar'
'and compare it with the arithmetic rule.'
''
'Copyright (C) 2019 Jean Forget  (JFORGET at cpan dot org)'
''
' This program is distributed under the same terms as Perl 5.16.3:'
' GNU Public License version 1 or later and Perl Artistic License'
''
' You can find the text of the licenses in the LICENSE file or at'
' https://dev.perl.org/licenses/artistic.html'
' and https://www.gnu.org/licenses/gpl-1.0.html.'
''
' Here is the summary of GPL:'
''
' This program is free software; you can redistribute it and/or modify'
' it under the terms of the GNU General Public License as published by'
' the Free Software Foundation; either version 1, or (at your option)'
' any later version.'
''
' This program is distributed in the hope that it will be useful,'
' but WITHOUT ANY WARRANTY; without even the implied warranty of'
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
' GNU General Public License for more details.'
''
' You should have received a copy of the GNU General Public License'
' along with this program; if not, write to the Free Software Foundation,'
' Inc., &lt;https://www.fsf.org/&gt;.'
∇
</pre>
<p>
Comme vous pouvez le deviner, ce résumé fait partie intégrante du
logiciel. Donc, une fois que vous êtes entrés sous APL et que vous
avez initialisé votre espace de travail avec mon script, vous pouvez
à tout moment afficher ce résumé.
</p>

<h1><a name='Introduction'>Introduction</a></h1>
<p>
Les programmes ci-dessous ont pour but d'examiner la règle des équinoxes
utilisée pour le calendrier républicain et implémentée par Nachum Dershowitz
et Edward Reingold en C-Lisp.</p>

<p>
La question essentielle que je cherche à résoudre est de savoir pendant
combien de temps les fonctions de calcul de CALENDRICA 3.0 permettent
de façon fiable de déterminer l'équinoxe d'automne. Mon but n'est pas de
critiquer les auteurs ni de suggérer qu'ils ont mal fait leur boulot.
Mon but est seulement d'apporter des éléments pour qu'un utilisateur puisse
élaborer un avis éclairé et argumenté sur les fonctions de calcul et pour
déterminer si les fonctions sont valables pour les dix prochains millénaires
ou seulement pour les deux prochains siècles.</p>

<p>
Cela dit, j'attire votre attention sur la clause <i lang='en'>NO WARRANTY</i>
des licences. Je propose des idées et des arguments. Mais c'est vous qui
élaborez vos conclusions, sous votre propre responsabilité. Ni Dershowitz,
ni Reingold, ni moi-même, ni aucune personne directement ou indirectement concernée par
ces textes et ces programmes ne pouvons être tenus pour responsables de
l'usage que vous en ferez.
</p>

<h1><a name='Analyse théorique'>Analyse théorique</a></h1>
<p>
Une année astronomique, ou année tropique, dure
31&nbsp;556&nbsp;925,9747&nbsp;secondes, soit 365,242198781&nbsp;jours, ce qui
nous donne la durée moyenne d'une année républicaine avec la règle des équinoxes.
Si l'on enlève les 365 jours entiers, il reste 0,242198781&nbsp;jour, soit
20&nbsp;925,9747 secondes.
Avec la règle arithmétique, l'année républicaine dure en moyenne
365,24225&nbsp;jours, soit 365&nbsp;jours plus 20&nbsp;930,4&nbsp;secondes.
L'année grégorienne dure en moyenne 365,2425&nbsp;jours, soit 365&nbsp;jours plus
20&nbsp;952&nbsp;secondes.</p>

<p>
L'année astronomique a donc 4,4253&nbsp;secondes de moins que l'année républicaine
arithmétique et 27,0253&nbsp;secondes de moins que l'année grégorienne. On peut donc
s'attendre à ce que l'année astronomique gagne un jour sur l'année républicaine
arithmétique en 19&nbsp;524&nbsp;ans et un jour sur l'année grégorienne en
3197&nbsp;ans.
</p>

<h1><a name='Analyse statistique'>Analyse statistique</a></h1>
<p>
Comme il est question de durées moyennes, il faudra travailler sur des listes
suffisamment longues d'années pour déterminer les durées individuelles et faire la
moyenne. Pour établir la liste, nous commençons par faire tourner <tt>cmpeq.cl</tt> et
nous stockons le résultat dans un fichier texte. Le contenu est&nbsp;:
</p>

<pre>
0   0    1    1 1
1...5....0....5.7
   3 1794 22 22  
   4 1795 23 22 +
   5 1796 22 22  
</pre>
<p>
Colonnes 1 à 4, année républicaine (les zéros de tête sont remplacés par des espaces),</p>

<p>
Colonnes 6 à 9, année grégorienne,</p>

<p>
Colonnes 11 et 12, jour de septembre où se produit le 1er Vendémiaire selon la règle des équinoxes,</p>

<p>
Colonnes 14 et 15, jour de septembre où se produit le 1er Vendémiaire selon la règle arithmétique,</p>

<p>
Colonne 17, un symbole visualisant les années où les deux règles diffèrent.
</p>

<h2><a name='equinoxrule∆vnd1eq'><tt>equinoxrule∆vnd1eq</tt></a></h2>
<p>
Comme le fichier produit par <tt>cmpeq.cl</tt> contient des données
de longueur fixe, il est très simple d'extraire les dates pour
la règle des équinoxes.
</p>

<pre>
∇ V ← equinoxrule∆vnd1eq FIC
V ← {⍎(⊃⍵)[11 12]} ⎕FIO[49] FIC
∇
</pre>
<h2><a name='equinoxrule∆vnd1ar'><tt>equinoxrule∆vnd1ar</tt></a></h2>
<p>
Et pour la règle arithmétique, c'est aussi simple&nbsp;:
</p>

<pre>
∇ V ← equinoxrule∆vnd1ar FIC
V ← {⍎(⊃⍵)[14 15]} ⎕FIO[49] FIC
∇
</pre>
<p>
Le seul problème, c'est que c'est spécifique à GNU-APL et que cela ne
fonctionnera pas sur les autres interpréteurs APL.
</p>

<h2><a name='Calcul des moyennes glissantes'>Calcul des moyennes glissantes</a></h2>
<p>
On dispose d'un vecteur V de N valeurs numériques et on veut calculer
les moyennes glissantes sur P valeurs successives. Ce qui donnera,
bien entendu, N+1-P valeurs moyennes.</p>

<p>
Pour des raisons expliquées ailleurs, on suppose que N vaut 6000 et P vaut 400.</p>

<p>
La première étape consiste à arranger les valeurs de V dans le tableau suivant
(N+1-P lignes, P colonnes)&nbsp;:
</p>

<pre>
V[1]      V[2]       V[3]     ... V[P-1]   V[P]
V[2]      V[3]       V[4]     ... V[P]     V[P+1]
V[3]      V[4]       V[5]     ... V[P+1]   V[P+2]
...       ...        ...          ...      ...
V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-2]   V[N-1]
V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-1]   V[N]
</pre>
<p>
Et ensuite, c'est l'enfance de l'art pour calculer les moyennes.
Mais comment arriver à un tel tableau&nbsp;? Il y a trois façons de procéder.</p>

<p>
La première façon consiste à créer un tableau de N+1-P lignes identiques de N colonnes&nbsp;:
</p>

<pre>
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
...       ...        ...          ...      ...
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
V[1]      V[2]       V[3]     ... V[N-1]   V[N]
</pre>
<p>
Ensuite, nous appliquons une rotation progressive à chaque ligne avec l'une de ces expressions&nbsp;:
</p>

<pre>
(¯1+⍳N+1-P)⌽V
(0,⍳N-P)⌽V
</pre>
<p>
ce qui donne&nbsp;:
</p>

<pre>

 V[1]      V[2]       V[3]     ... V[N-1]       V[N]
 V[2]      V[3]       V[4]     ... V[N]         V[1]
 V[3]      V[4]       V[5]     ... V[1]         V[2]
 ...       ...        ...          ...          ...
 V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-(2+P)]   V[N-(1+P)]
 V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-(1+P)]   V[N-P]
</pre>
<p>
Et ensuite il ne reste plus qu'à tronquer en prenant les P premières colonnes.
Mais pour cela, nous avons eu besoin de deux tableaux à N × (N+1-P) valeurs.
Avec N=6000 et P=400, cela nous donne une taille totale de 2 × 5601 × 6000
soit 67212000 valeurs.
</p>

<p>
La deuxième façon de constituer le tableau pour calculer les moyennes glissantes
consiste à passer par l'intermédiaire d'un tableau T à N+1 colonnes et N+1-P
lignes. Lors de la création de ce tableau, les éléments de V remplissent les N
premières colonnes de T. Et pour remplir T[1;N+1], on recommence à dérouler V
et on stocke ainsi V[1] dans T[1;N+1]. Du coup, à la ligne suivante, c'est V[2]
qui se retrouve dans T[2;1]. Le dernier élément V[N] atterrit dans T[2;N-1] et
il reste deux places de libres, qui seront occupées par V[1] et V[2] lors du
troisième déroulement de V. Donc, T[3;1] contiendra V[3]. Cela donne
</p>

<pre>
 1         2          3            N-1          N          N+1
V[1]      V[2]       V[3]     ... V[N-1]       V[N]        V[1]
V[2]      V[3]       V[4]     ... V[N]         V[1]        V[2]
V[3]      V[4]       V[5]     ... V[1]         V[2]        V[3]
...       ...        ...          ...          ...
V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-(2+P)]   V[N-(1+P)]  V[N-P]
V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-(1+P)]   V[N-P]      V[N+1-P]
</pre>
<p>
Ainsi, rien qu'en ajoutant une colonne, soit N+1-P valeurs, on obtient la
rotation progressive pour presque rien et on utilise alors un seul tableau
intermédiaire au lieu de deux.</p>

<p>
Mais on peut faire mieux. Le motif de rotation progressive d'une ligne à l'autre
se retrouve aussi lorsque l'on examine le tableau colonne par colonne.
D'où la troisième façon, qui consiste à générer le tableau avec N+1 colonnes,
mais seulement P lignes au lieu de N+1-P. Ensuite, on tronque à N+1-P colonnes
au lieu de P, ce qui fait que les lignes attendues se retrouvent sous la forme
de colonnes. Il suffit alors de faire une transposition pour que les lignes
se retrouvent bien en tant que lignes. Certes, il y a deux tableaux intermédiaires
au lieu d'un seul, mais ces deux tableaux ont P lignes et environ N colonnes,
ce qui est meilleur qu'un tableau à environ N lignes et N colonnes, pour peu que
P soit inférieur à N÷3. Les deux tableaux intermédiaires sont :
</p>

<pre>
 1         2          3            N-1          N          N+1
V[1]      V[2]       V[3]     ... V[N-1]       V[N]        V[1]
V[2]      V[3]       V[4]     ... V[N]         V[1]        V[2]
V[3]      V[4]       V[5]     ... V[1]         V[2]        V[3]
...       ...        ...          ...          ...
V[P-1]    V[P]       V[P+1]   ... V[P-3]       V[P-2]      V[P-1]
V[P]      V[P+1]     V[P+2]   ... V[P-2]       V[P-1]      V[P]
</pre>
<p>
Puis
</p>

<pre>
 1         2          3            N-(P+1)      N-P        N+1-P
V[1]      V[2]       V[3]     ... V[N-(P+1)]   V[N-P]      V[N+1-P]
V[2]      V[3]       V[4]     ... V[N-P]       V[N+1-P]    V[N+2-P]
V[3]      V[4]       V[5]     ... V[N+1-P]     V[N+2-P]    V[N+3-P]
...       ...        ...          ...          ...
V[P-1]    V[P]       V[P+1]   ... V[N-3]       V[N-2]      V[N-1]
V[P]      V[P+1]     V[P+2]   ... V[N-2]       V[N-1]      V[N]
</pre>
<p>
Ce sera donc la méthode que nous adopterons. Éh bien non&nbsp;!
En effet, le tableau
</p>

<pre>
V[1]      V[2]       V[3]     ... V[P-1]   V[P]
V[2]      V[3]       V[4]     ... V[P]     V[P+1]
V[3]      V[4]       V[5]     ... V[P+1]   V[P+2]
...       ...        ...          ...      ...
V[N-P]    V[N+1-P]   V[N+2-P] ... V[N-2]   V[N-1]
V[N+1-P]  V[N+2-P]   V[N+3-P] ... V[N-1]   V[N]
</pre>
<p>
n'est pas le but ultime du calcul, le but ultime est le vecteur de moyennes
glissantes. Et il est tout-à-fait possible de calculer ce vecteur de moyennes
glissantes à partir du précédent tableau intermédiaire, celui d'avant la
transposition. Au lieu de faire la totalisation par lignes avec
«&nbsp;<tt>+/</tt>&nbsp;», on fera la totalisation par colonne avec
«&nbsp;<tt>+⌿</tt>&nbsp;».
</p>

<h2><a name='equinoxrule∆movingav'><tt>equinoxrule∆movingav</tt></a></h2>
<p>
Au final, la fonction est donc&nbsp;:
</p>

<pre>
∇ R ← P equinoxrule∆movingav V;N;T
N ← (⍴V)[1]
T ← (P,N+1-P) ↑ (P,N+1) ⍴ V
R ← (+⌿T) ÷ P
∇
</pre>
</body>
</html>
